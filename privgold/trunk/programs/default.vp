uniform int light_enabled[gl_MaxLights];
uniform int max_light_enabled;
uniform vec4 detail0Plane;
uniform vec4 detail1Plane;
void main() {

  vec4 position=gl_ModelViewMatrix*gl_Vertex;
  vec3 eyetopos=normalize(position.xyz/position.w);//find the direction from eye to object
  vec3 normal = normalize(gl_NormalMatrix * gl_Normal);//normalize the normal in world space
  gl_TexCoord[0]=gl_MultiTexCoord0;
  //gl_TexCoord[7]=gl_MultiTexCoord0*detail0Plane;//detail texture

  gl_TexCoord[1].xyz=normal;
  gl_TexCoord[4].xyz=-eyetopos;//direction from vertex to eye
  vec3 forward=gl_NormalMatrix*vec3(0.01,.01,1);//cheat use forward of ship to compute tangent

  vec3 binormal=normalize(cross(forward,normal));//gramm schmitt orthonormalization process
  vec3 tangent=normalize(cross(binormal,normal));
  gl_TexCoord[2].xyz=tangent;
  gl_TexCoord[3].xyz=binormal;
  vec3 source0pos=gl_LightSource[0].position.xyz*position.w-position.xyz*gl_LightSource[0].position.w;
  vec3 source1pos=gl_LightSource[1].position.xyz*position.w-position.xyz*gl_LightSource[1].position.w;
  float source0len=length(source0pos);
  float source1len=length(source1pos);
  gl_TexCoord[5].w=(gl_LightSource[0].constantAttenuation+gl_LightSource[0].linearAttenuation*source0len+gl_LightSource[0].quadraticAttenuation*source0len*source0len);
  gl_TexCoord[6].w=(gl_LightSource[1].constantAttenuation+gl_LightSource[1].linearAttenuation*source1len+gl_LightSource[1].quadraticAttenuation*source1len*source1len);
  gl_TexCoord[5].xyz=source0pos/source0len;//find the direction of the vertex to the light...if not directional position.w==1
  gl_TexCoord[6].xyz=source1pos/source1len;
  gl_TexCoord[2].w=gl_TexCoord[3].w=gl_TexCoord[4].w=gl_TexCoord[1].w=0.0;
  ///set primary color to the front light[0] ambient and light model ambient + emissive material properties
  vec4 pc=gl_FrontLightProduct[0].ambient+gl_FrontLightModelProduct.sceneColor;
  if (light_enabled[1]!=0)
    pc+=gl_FrontLightProduct[1].ambient;
  vec4 sc=vec4(0);
  if (max_light_enabled>=2) {
    for (int li=2;li<gl_MaxLights;++li) {//computed in engine
      //if (li>max_light_enabled) break;
      if (light_enabled[li]!=0) {//only compute for enabled lights
      //do per vertex lighting for lights 1,2,3,4,5,6,7+
        vec3 lightvec=gl_LightSource[li].position.xyz*position.w-position.xyz*gl_LightSource[li].position.w;
        float dist=length(lightvec);
        vec4 att = 1.0 / (gl_LightSource[li].constantAttenuation +
  	                 gl_LightSource[li].linearAttenuation * vec4(dist) +
	                 gl_LightSource[li].quadraticAttenuation * vec4(dist * dist));
        lightvec=lightvec/dist;
        vec3 halfangle=lightvec-eyetopos;
        halfangle=halfangle/length(halfangle);
        pc+=att*(gl_FrontMaterial.emission+gl_FrontMaterial.ambient*(gl_LightSource[li].ambient)
          + max(dot(normal,lightvec),0.0)*gl_LightSource[li].diffuse*gl_FrontMaterial.diffuse);
        sc+=att*gl_FrontMaterial.specular*gl_LightSource[li].specular*pow(max(dot(normal,halfangle),0.0),gl_FrontMaterial.shininess);
      }
    }
  }
//FIXME this may be better served as an ftransform--but I figure this will get more opts in the future
  gl_Position=gl_ModelViewProjectionMatrix*gl_Vertex;
  gl_FrontColor=gl_BackColor=pc;
  gl_FrontSecondaryColor=sc;
}